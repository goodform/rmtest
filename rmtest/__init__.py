import unittest
from .disposableredis import DisposableRedis
import os
import contextlib
from redis import ResponseError


REDIS_MODULE_PATH_ENVVAR = 'REDIS_MODULE_PATH'
REDIS_PATH_ENVVAR = 'REDIS_PATH'
REDIS_PORT_ENVVAR = 'REDIS_PORT'


class BaseModuleTestCase(unittest.TestCase):

    def tearDown(self):
        if hasattr(self, '_server'):
            self._server.stop()
            self._server = None
            self._client = None

        super(BaseModuleTestCase, self).tearDown()

    @property
    def server(self):
        self._ensure_server()
        return self._server

    @property
    def client(self):
        self._ensure_server()
        return self._client

    def spawn_server(self, **extra_args):
        if hasattr(self, '_server'):
            raise Exception('Server already spawned!')
        self._ensure_server(**extra_args)

    def restart_and_reload(self):
        self._server.dump_and_reload(restart_process=True)
        self._client = self._server.client()

    def _ensure_server(self, **args):
        if getattr(self, '_server', None):
            return
        self._server = self.redis(**args)
        self._server.start()
        self._client = self._server.client()

    def redis(self, *args, **kwargs):
        raise NotImplementedError()

    def cmd(self, *args, **kwargs):
        return self.client.execute_command(*args, **kwargs)

    def assertOk(self, x, msg=None):
        if type(x) == type(b""):
            self.assertEqual(b"OK", x, msg)
        else:
            self.assertEqual("OK", x, msg)

    def assertCmdOk(self, cmd, *args, **kwargs):
        self.assertOk(self.cmd(cmd, *args, **kwargs))

    def assertExists(self, r, key, msg=None):
        self.assertTrue(r.exists(key), msg)

    def assertNotExists(self, r, key, msg=None):
        self.assertFalse(r.exists(key), msg)

    def retry_with_reload(self):
        return self.client.retry_with_rdb_reload()

    @contextlib.contextmanager
    def assertResponseError(self, msg=None):
        """
        Assert that a context block with a redis command triggers a redis error response.

        For Example:

            with self.assertResponseError():
                r.execute_command('non_existing_command')
        """

        try:
            yield
        except ResponseError:
            pass
        else:
            self.fail("Expected redis ResponseError " + (msg or ''))


def ModuleTestCase(module_path, redis_path='redis-server', fixed_port=None, redis_port=None, module_args=tuple()):
    """
    Inherit your test class from the class generated by calling this function
    module_path is where your module.so resides, override it with REDIS_MODULE_PATH in env
    redis_path is the executable's path, override it with REDIS_PATH in env
    redis_port is an optional port for an already running redis
    module_args is an optional tuple or list of arguments to pass to the module on loading
    """

    module_path = os.getenv(REDIS_MODULE_PATH_ENVVAR, module_path)
    redis_path = os.getenv(REDIS_PATH_ENVVAR, redis_path)
    fixed_port = os.getenv(REDIS_PORT_ENVVAR, fixed_port)

    # If we have module args, create a list of arguments
    loadmodule_args = module_path if not module_args else [
        module_path] + list(module_args)

    class _ModuleTestCase(BaseModuleTestCase):

        _module_path = os.path.abspath(os.path.join(os.getcwd(), module_path))
        _loadmodule_args = loadmodule_args

        _redis_path = redis_path

        def redis(self, port=None, **kwargs):
            if fixed_port is not None:
                port = fixed_port
            return DisposableRedis(port=port, path=self._redis_path, loadmodule=self._loadmodule_args, **kwargs)

    return _ModuleTestCase
